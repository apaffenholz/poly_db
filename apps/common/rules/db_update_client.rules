# Copyright (c) 2013-2014 Silke Horn
# http://solros.de/polymake/poly_db
# 
# This file is part of the polymake extension poly_db.
# 
# poly_db is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# poly_db is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with poly_db.  If not, see <http://www.gnu.org/licenses/>.

CREDIT poly_db


use Sys::Hostname;
use DateTime;

# @category Database Admin
# Updates a pack of objects in the collection SmoothReflexive in the database LatticePolytopesR. 
# Moreover, it matches their properties with the template object for this collection.
# 
# Note that you need write access to the database for this. You will be asked for credentials if you don't specify them.
# 
# Contained in extension ''poly_database''.
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option Int package_size default 100
# @option String contrib use this to update the [[contributor]]
user_function db_do_package ({local => 0, username => $db_user, password => $db_pwd, contrib => "", package_size => 100, client => undef}){
	my $options = shift;
	
	my $n = db_get_package("LatticePolytopesR", "SmoothReflexive", lup($options), client => $options->{client});

	db_batch_update_smooth_reflexive($n, $options);
		
	db_finish_package("LatticePolytopesR", "SmoothReflexive", $n, lup($options), client => $options->{client})	
}

# @category Database Admin
# Perpetually works on the database until it is killed.
# 
# Note that you need write access to the database for this. You will be asked for credentials if you don't specify them.
# 
# Contained in extension ''poly_database''.
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option Int package_size default 100
# @option String contrib use this to update the [[contributor]]
user_function db_work_on_packages ({local => 0, username => $db_user, password => $db_pwd, contrib => "", package_size => 100}) {

	my $options = shift;
	my $client = get_client($options);
	
	while (my $next = db_get_package("LatticePolytopesR", "SmoothReflexive", lup($options), client => $client)) {
	
		db_batch_update_smooth_reflexive($next, $options, client => $client);
		
		db_finish_package("LatticePolytopesR", "SmoothReflexive", $next, lup($options), client => $client);
	}
}

# @category Database Admin
# Updates a pack of objects in the collection SmoothReflexive in the database LatticePolytopesR. 
# Moreover, it matches their properties with the template object for this collection.
# 
# Note that you need write access to the database for this. You will be asked for credentials if you don't specify them.
# 
# Contained in extension ''poly_db''.
# @param Int package
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option Int package_size default 100
# @option String contrib use this to update the [[contributor]]
function db_batch_update_smooth_reflexive($, {local => 0, username => $db_user, password => $db_pwd, contrib => "", package_size => 100, client => undef}) {
	my ($pack, $options) = @_;

	my $u = $options->{username};
	my $p = $options->{password};
	my $local = $options->{local};
	my $ps = $options->{package_size};

	my $db_name = "LatticePolytopesR";
	my $col_name = "SmoothReflexive";

	my $dim = 8;

	my $client;
	unless(defined($client = $options->{client})) {
		$client	= get_client($options);
	}
	
	my $t = get_template_object($db_name, $col_name, local => $local, client => $client);
	
	my $fst = $pack*$ps;	# the number of the first object in the package
	
	
	for (my $i = 0; $i < $ps; ++$i) {
		my $id = get_id($dim, $fst+$i);
		my $obj;
		unless ($obj = poly_db_one({'_id' => $id}, lup($options), client => $client, db => $db_name, collection => $col_name)) {
			croak("non-existent id: $id\n");
		}

		my $contrib;
		unless ($contrib = $options->{contrib}) {
			$contrib = $obj->contributor;	
		}
		
		my $output = db_update_one($db_name, $col_name, $obj, local => $local, username => $u, password => $p, contrib => $contrib, template => $t, client => $client);
		
		if ($output->{ok}) {
			print $id." ";
		} else {
			print "\nan error occurred when updating $id\n";
		}
	}
}


# @category Database Admin
# Finds a packages that is neither done nor active. Write to the database that this package is now active and record starttime and host.
# @param String db
# @param String col
# @return Int
function db_get_package($, $, {local => 0, username => $db_user, password => $db_pwd, client => undef}) {
	my ($db_name, $col_name, $options) = @_;
	my $u = $options->{username};
	my $p = $options->{password};
	my $local = $options->{local};
		
	my $client;
	unless(defined($client = $options->{client})) {
		$client	= get_client($local, $u, $p);
	}
	
	my $col = get_collection($client, $db_name, $col_name."_status");
	
	my $package = $col->find_one({'done'=>0, 'active'=>0});
	my $id = $package->{_id};

	$col->update({'_id' => $id},{'$set' => {'active'=>1} });


	$col->update({'_id' => $id},{'$set' => {'active'=>1, 'hostname'=>hostname(), 'start'=>DateTime->now} });
	
	print hostname() . " started working on package $id at " . DateTime->now . "\n";
	
	return $id;
}

# Writes to the database that package //id// is finished and records end time.
# @param String db
# @param String col
# @param Int id
# @option Bool reset
function db_finish_package($, $, $, {local => 0, username => $db_user, password => $db_pwd, reset => 0, client => undef}) {
	my ($db_name, $col_name, $id, $options) = @_;
	my $u = $options->{username};
	my $p = $options->{password};
	my $local = $options->{local};
	
	my $client;
	unless(defined($client = $options->{client})) {
		$client	= get_client($local, $u, $p);
	}
	
	my $col = get_collection($client, $db_name, $col_name."_status");
	
	if ($options->{reset}) {
		$col->update({'_id'=>$id},{'$set' => {'done'=>0, 'active'=>0} });
		print "reset package $id\n";
	
	} else {
		$col->update({'_id'=>$id},{'$set' => {'done'=>1, 'end'=>DateTime->now} });
		print "\n".hostname() . " finished working on package $id at " . DateTime->now . "\n";
	}
}

# @category Database Admin
# Subdivides all objects into packages that are to be updated. (E.g. by computing missing properties.)
# 
# Contained in extension ''poly_database''.
# @param String db
# @param String col
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option Int package_size default 100
user_function create_packages ($, $, {local => 0, username => $db_user, password => $db_pwd, package_size => 100}) {
	my ($db_name, $col_name, $query, $options) = @_;
	
	my $total = poly_db_count({}, $options, db => $db_name, collection => $col_name);
	
	my $npacks = ceil($total/$options->{package_size});
	
	my $client = get_client($options);
	
	# create new collection to store packages with status
	my $col = get_collection($client, $db_name, $col_name."_status");
	
	for (my $i = 0; $i < $npacks; ++$i) {
		$col->insert({'_id'=>$i, 'done'=>0, 'active'=>0});
	}
	
	undef $client;
}



# @category Database Admin
# Prints all active packages in the collection //col// in database //db// with start time and host computer.
# 
# Contained in extension ''poly_database''.
# @param String db
# @param String col
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option Bool v set to 1 if you want to have many details
# @option Int older_than only show packages with start time //older_than// hours ago, set to 0 to show everything TODO
# @option Bool print_reset_code set this to 1 if you want to get the reset code for every active package (you need write access to reset), default 0
user_function show_active_packages ($, $, {local => 0, username => $db_user, password => $db_pwd, print_reset_code => 0, v => 0, older_than => 0}) {
	my ($db_name, $col_name, $options) = @_;
	
	my $client = get_client($options);
	
	my $col = get_collection($client, $db_name, $col_name."_status");
	
	my $active = $col->find({'done'=>0, 'active'=>1});

	my %h = ();

	my $now = DateTime->now;
	while (my $p = $active->next) {
		$h{$p->{hostname}}++;
		if ($options->{v}) {
			my $dur = $now - $p->{start};
			my $mins = $dur->{minutes};
			if ($mins >= $options->{older_than}*60) {
				print "id: ". $p->{_id}."\nstart: ".$p->{start}."\nhost: ".$p->{hostname}."\n";
				if ($options->{print_reset_code}) { 
					print "reset with\ndb_finish_package('$db_name','$col_name',".$p->{_id}.",username=>'".$options->{username}."',password=>'".$options->{password}."',reset=>1);"."\n\n";
				}
			}
		}
		print "\n";
	}
	print "\nnumber of active processes: ".$active->count."\n";
	print "\npackages by host: \n";
	foreach (keys %h) {
		print $_ . ": " . $h{$_}."\n";
	}
	
	undef $client;
}

# @category Database Admin
# Resets all active packages in the collection //col// in database //db//. Only use this if you are sure that they are no longer being processed.
# 
# Contained in extension ''poly_database''.
# @param String db
# @param String col
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
user_function reset_active_packages ($, $, {local => 0, username => $db_user, password => $db_pwd}) {
	my ($db_name, $col_name, $options) = @_;
	
	my $client = get_client($options);
	
	my $col = get_collection($client, $db_name, $col_name."_status");
	
	my $active = $col->find({'done' => 0, 'active' => 1});

	while (my $p = $active->next) {
		db_finish_package($db_name, $col_name, $p->{_id}, $options, reset=>1);
	}
	undef $client;
}



sub get_id {
	my ($d, $i) = @_;
	
	if ($d <= 6) {
		return sprintf ("F.%dD.%04d", $d, $i);
	}
	if ($d == 8) {
		return sprintf ("F.%dD.%06d", $d, $i);
	}
}
