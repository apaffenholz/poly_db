# Copyright (c) 2013-2014 Silke Horn
# http://solros.de/polymake/poly_db
# 
# This file is part of the polymake extension polyDB.
# 
# polyDB is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# polyDB is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with polyDB.  If not, see <http://www.gnu.org/licenses/>.


# This is a helper function that transforms a database cursor into an array of polymake objects.
function cursor2array {
	my ($cursor, $t, $db_name, $col_name) = @_;
	my $size = $cursor->count(1);

	my $app = defined($t) ? $t->{'app'}:$cursor->[0]->{'app'};
	my $type = defined($t) ? $t->{'type'}:$cursor->[0]->{'type'};

	my $obj_type = User::application($app)->eval_type($type);
	my $arr_type = User::application($app)->eval_type("Array<$type>");

	my $parray = $arr_type->construct->($size+0);
	my $i = 0;
	while (my $p = $cursor->next) {		
		$parray->[$i] = doc2object_internal($p, $db_name, $col_name, $obj_type);
		++$i;
	}
	return $parray;

}

# This is a helper function that transforms a database cursor into an array of strings (IDs).
function cursor2stringarray {
	my $cursor = shift;
	
	my @parray = ();
	while (my $p = $cursor->next) {
		push @parray, $p->{_id};
	}
	return @parray;

}



# This is a helper function that transforms a database document into an object.
function doc2object {
	my $doc = shift;
	my $t = shift;
	my $db_name = shift;
	my $col_name = shift;
	
	my $app = defined($doc->{'app'}) ? $doc->{'app'}:$t->{'app'};
	my $type = defined($doc->{'type'}) ? $doc->{'type'}:$t->{'type'};

	my $obj_type = User::application($app)->eval_type($type);
	return doc2object_internal($doc, $db_name, $col_name, $obj_type);
}

sub doc2object_internal {
	my ($doc, $db_name, $col_name, $obj_type) = @_; 

	delete $doc->{'app'};
	delete $doc->{'type'};
	delete $doc->{'name'};
	delete $doc->{'version'};
	delete $doc->{'ext'};
	delete $doc->{'description'};
	
	return $obj_type->construct->($doc->{'_id'}, %$doc, database=>$db_name, collection=>$col_name);

}


# @category Database
# Takes local and (optionally) username and password and returns a mongo client.
# @param Bool local
# @param String username optional
# @param String password optional
# @return MongoClient
function get_client {
	my @args = @_;
	my ($local, $u, $p);
	if (@args == 3) {
		($local, $u, $p) = @args;
	} else {
		my $h = $args[0];
		$local = $h->{local};
		$u = $h->{username};
		$p = $h->{password};
	}

	my $client;
	if ($local) {
		$client = MongoDB::MongoClient->new;
	} elsif (!$u || !$p) {
		$client = MongoDB::MongoClient->new(host=>$db_host.":".$db_port, db_name=>$auth_db, username=>$db_user, password=>$db_pwd);
	} else {
		$client = MongoDB::MongoClient->new(host=>$db_host.":".$db_port, db_name=>$auth_db, username=>$u, password=>$p);
	}
	return $client;
}

# returns the database entry with the type information for a given collection
function get_type {
	my ($client, $db_name, $collection) = @_;
	return $client->get_database($type_db)->get_collection("Types")->find_one({db => $db_name, col => $collection});
}

# returns a collection object
function get_collection {
	my ($client, $db_name, $collection) = @_;
	my $db = $client->get_database($db_name);
	return $db->get_collection($collection);
}


# the current date as a string in the form yyyy-mm-dd
sub get_date {
	use DateTime;

	my $dt = DateTime->today;
	return $dt->date;
}

# generates a unique ID for the object from the name of the file
function generate_id {
	my ($name, $db, $col) = @_;
	
	if ($col eq "SmoothReflexive") {
		if ($name =~ m/\.(\d+D)\.(\d+)/) {
			return "F.$1.$2";
		} else {
			croak("name $name does not yield valid id for collection $col\n");
			return;
		}
	}
	
	croak("no rule to generate id for collection $col\n");
	return;
}


# generates a hash containing local, username and password from a possibly larger one
function lup {
	my $o = shift;
	my $r = {};
	$r->{local}=$o->{local};
	$r->{username}=$o->{username};
	$r->{password}=$o->{password};
	return $r;
}



sub remove_props {
	my ($db, $col, $client, $options) = @_;
	my $rem_props;
	unless (defined($rem_props = $options->{rem_props})) {
		$rem_props = ["database","collection"];
		if (my $type = get_type($client, $db, $col)) {
			push @$rem_props, keys %$type;
		}
	}
	return $rem_props;
}
