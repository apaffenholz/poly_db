# Copyright (c) 2013-2014 Silke Horn
# http://solros.de/polymake/poly_db
# 
# This file is part of the polymake extension polyDB.
# 
# polyDB is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# polyDB is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with polyDB.  If not, see <http://www.gnu.org/licenses/>.



# @category Database Write Access
# Adds an object //obj// to the collection //col// in the database //db//.
# 
# Note that you need write access to the database for this.
# 
# Contained in extension ''polyDB''.
# @param Core::Object obj
# @param String db database name
# @param String col collection name
# @option String id unique identifier
# @option String contrib set the contributor
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option Bool use_template set to 1 to match properties with a template object  
# @option Bool nonew set to 1 if you don't want to compute missing properties but only delete surplus ones (only takes effect if use_template is also set to 1)
# @option Core::Object template can be precomputed for better performance when applying to multiple objects (implies use_template => 1)
# @option MongoClient client
# @return String
user_function db_insert ($, $, $, {local => 0, id => "", contrib => "", username => $db_user, password => $db_pwd, nonew => 0, use_template => 0, template => undef, keep_all_props=> 0, client => undef, rem_props => undef}) {
	my ($obj, $db, $col, $options) = @_;
 	 	
	# get client if not given by the options
	my $client;
	unless (defined($client = $options->{client})) {
		$client = get_client($options);
	}
	
 	check_type($obj, $db, $col, $client);
	
	my $rem_props = remove_props_insert($db, $col, $client, $options);

	# get template object if not given by the options
	my $temp;
	if ($options->{use_template} or defined($temp = $options->{template})) {
		unless (defined($temp)) {
			$temp = get_template_data($db, $col, local => $options->{local}, client => $client);
		}
		if (!$options->{nonew}) {
			compute_properties($obj, $temp);
		}
		if (!$options->{keep_all_props}) {
			
		}
	}
	
	my $collection = get_collection($client, $db, $col);

#	my $json = pm2json($obj, {contributor => $options->{contrib}}, $rem_props, $options->{id}, 0, $temp);
	my $json = PolyDB::DirectJSONwriter::json_save($obj, {contributor => $options->{contrib}, id=>$options->{id}});
	my $output = $collection->insert(::JSON->new->utf8->decode($json));
	return $output;
}


# @category Database Write Access
# Adds an object from a file //file// to the collection //col// in the database //db//. First it matches its properties with the template object for this collection (unless your options say otherwise).
# 
# Note that you need write access to the database for this.
# 
# Contained in extension ''polyDB''.
# @param String file polymake object stored in a file
# @param String db database name
# @param String col collection name
# @option String id unique identifier, if you don't specify one, polyDB will try to create one from the object name or file name, if this does not work out one will be created automatically
# @option String contrib set the contributor
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option Bool use_template set to 1 to match properties with a template object. 
# @option Bool nonew set to 1 if you don't want to compute missing properties but only delete surplus ones (only takes effect if use_template is also set to 1)
# @option Core::Object template can be precomputed for better performance when applying to multiple objects (implies use_template => 1)
# @option MongoClient client
# @return String
user_function db_insert_from_file($, $, $, {local => 0, username => $db_user, password => $db_pwd, id => "", contrib => "", nonew => 0, use_template => 0, template => undef, client => undef, rem_props => undef}) {
	my ($file, $db, $col, $options) = @_;

	my $obj = User::load($file);
	
	my $id = $options->{id};
	
	unless ($id) {
		if ($id = generate_id($file, $db, $col)) {
			$options->{"id"} = $id;
		}
	}
	
	return db_insert($obj, $db, $col, $options);
}


# @category Database Write Access
# Adds a list of objects from files to the collection //col// in the database //db//. It assumes that the objects names can be used to generate unique ids. Objects with ids that are already contained in the database will be skipped (and moved to //move_dir// if indicated).
# 
# TODO: It still processes (and inserts) the files one by one (which is fine if the objects are relatively large). If one wants to insert a large number of very small objects there is a more efficient way of doing this.
# 
# Note that you need write access to the database for this.
# 
# Contained in extension ''polyDB''.
# @param Array<String> files list of file names
# @param String db database name
# @param String col collection name
# @option String contrib
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option Bool use_template set to 1 to match properties with a template object. 
# @option Bool nonew set to 1 if you don't want to compute missing properties but only delete surplus ones
# @option String move_dir directory in which processed files are moved
# @option Bool verbose print database output
# @option MongoClient client
user_function db_batch_insert ($, $, $, {contrib => "", local => 0, username => $db_user, password => $db_pwd, nonew => 0, use_template => 0, move_dir => "", client => undef, rem_props => undef}){
	my ($files, $db_name, $collection, $options) = @_;
	
	my @files = @$files;
	
	# get client if not given by the options
	my $client;
	unless (defined($client = $options->{client})) {
		$client = get_client($options);
	}

	# get template object if needed
	my $temp;
	if ($options->{use_template}){
		$temp = get_template_object($db_name, $collection, local => $options->{local}, client => $client);
	}

	my $rem_props = remove_props_insert($db_name, $collection, $client, $options);

		
	print "inserting ...\n";
	foreach (@files) {
		my $obj = User::load($_);
		$obj->CONE_DIM;
		if ($options->{use_template} && !$options->{nonew}) {
			copy_properties($obj, $temp);
		}
	}

	my $col = get_collection($client, $db_name, $collection);
	
	my $md = $options->{move_dir};
	if ($md) {
		system("mkdir -p $md");
	}
	
	foreach my $file (@files) {
		my $obj = User::load($file);

	 	#check_type($obj, $db_name, $collection, $client);

		my $id = generate_id($obj->name, $db_name, $collection);
		
		if ($col->find_one({'_id'=>$id})) {
			if ($md) {
				system("mv $file $md");
			}	
			next;
		}

		my $json = pm2json($obj, {contributor => $options->{contrib}}, $rem_props, $id, 0, $temp);

		my $output = $col->insert($json);
		if ($options->{verbose}) {print "$output ";}

		if ($md) {
			system("mv $file $md");
		}
	}
	
	unless (defined($options->{client})){
		undef $client;
	}
	print "\n";
}


# @category Database Write Access
# Adds a list of objects from a pdata file to the collection //col// in the database //db//. It assumes that the objects names can be used to generate unique ids. Objects with ids that are already contained in the database will be skipped.
# 
# TODO: It still processes (and inserts) the files one by one (which is fine if the objects are relatively large). If one wants to insert a large number of very small objects there is a more efficient way of doing this.
# 
# Note that you need write access to the database for this.
# 
# Contained in extension ''polyDB''.
# @param String file pdata file (created with [[save_data]])
# @param String db database name
# @param String col collection name
# @option String contrib
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option Bool use_template set to 1 to match properties with a template object.
# @option Core::Object template (implies //use_templates//=>1)
# @option Bool nonew set to 1 if you don't want to compute missing properties but only delete surplus ones
# @option Bool verbose print database output
# @option MongoClient client
user_function db_insert_pdata ($, $, $, {contrib => "", local => 0, username => $db_user, password => $db_pwd, nonew => 0, use_template => 0, move_dir => "", client => undef, rem_props => undef, template => undef, verbose => 0}){
	my ($file, $db_name, $collection, $options) = @_;
	
	# get client if not given by the options
	my $client;
	unless (defined($client = $options->{client})) {
		$client = get_client($options);
	}

	my $col = get_collection($client, $db_name, $collection);

	# get template object if needed
	my $temp;
	if ($options->{use_template} || defined($options->{template})){
		$temp = defined($options->{template}) ? $options->{template} : get_template_object($db_name, $collection, local => $options->{local}, client => $client);
		unless ($temp) {croak("no template object\n");}
	}

	my $rem_props = remove_props_insert($db_name, $collection, $client, $options);

	my $objects = User::load_data($file);
		
	print "inserting ...\n";
	my $count = 0;
	foreach my $obj (@$objects) {
		$obj->CONE_DIM;
		$obj->N_FACETS;

		my $id = generate_id($obj->name, $db_name, $collection);
		
		if ($col->find_one({'_id' => $id})) {	
			if ($options->{verbose}) { print "id $id already exists\n"; }
			next;
		}

		if ($options->{use_template} && !$options->{nonew}) {
			copy_properties($obj, $temp);
		}

		my $json = pm2json($obj, {contributor => $options->{contrib}}, $rem_props, $id, 0, $temp);
		my $output = $col->insert($json);
		if ($options->{verbose}) { print "$output "; }
		$count++;

	}
	
	unless (defined($options->{client})){
		undef $client;
	}
	print "Inserted $count objects.\n\n";
}



# @category Database Write Access
# Removes the object with a given //id// from the collection //col// in the database //db//.
# 
# Note that you need write access to the database for this.
# 
# Contained in extension ''polyDB''.
# @param String id
# @param String db database name
# @param String col collection name
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option MongoClient client
# @return String
user_function db_remove ($, $, $, {local => 0, username => $db_user, password => $db_pwd, client => undef}) {
	my ($id, $db_name, $col_name, $options) = @_;

	# get client if not given by the options
	my $client;
	unless (defined($client = $options->{client})) {
		$client = get_client($options);
	}

	my $col = get_collection($client, $db_name, $col_name);
	
	return $col->remove({'_id' => $id});
}

