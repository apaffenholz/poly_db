# Copyright (c) 2013-2014 Silke Horn
# http://solros.de/polymake/poly_db
# 
# This file is part of the polymake extension polyDB.
# 
# polyDB is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# polyDB is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with polyDB.  If not, see <http://www.gnu.org/licenses/>.

CREDIT polyDB


use Term::ReadKey;


function get_credentials {
	# TODO: cache, key chain??
	print "user name: ";
	my $u= <STDIN>;
	ReadMode 2;
	print "password: ";
	my $p= <STDIN>;
	ReadMode 0;
	print "\n";
	chomp($u);
	chomp($p);
	print "Do you want to save these credentials in your custom settings? (This will overwrite any current user and password settings.) [yes/NO]: ";
	my $answer = <STDIN>;
	chomp($answer);
	print "\n";
	if ($answer == "yes") {
		set_custom $db_user = $u;
		set_custom $db_pwd = $p;
	}
	print "Successfully saved user settings for $u.\n";
	return ($u,$p);
}

# @category Database Write Access
# Adds an object //obj// to the collection //col// in the database //db//.
# 
# Note that you need write access to the database for this. You will be asked for credentials if you don't specify them.
# 
# Contained in extension ''polyDB''.
# @param Core::Object obj
# @param String db database name
# @param String col collection name
# @option String id unique identifier
# @option String contrib set the contributor
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option Bool use_template set to 1 to match properties with a template object. 
# @option Bool nonew set to 1 if you don't want to compute missing properties but only delete surplus ones (implies use_template => 1)
# @option Core::Object template can be precomputed for better performance when applying to multiple objects
# @option MongoClient client
# @return String
user_function db_insert ($, $, $, {local => 0, id => "", contrib => "", username => $db_user, password => $db_pwd, nonew => 0, use_template => 0, template => undef, client => undef, rem_props => undef}){
	my ($obj, $db, $col, $options) = @_;
 		
	# get client if not given by the options
	my $client;
	unless (defined($client = $options->{client})) {
		$client = get_client($options);
	}
	
	my $rem_props = remove_props($db, $col, $client, $options);

	# get template object if not given by the options
	if ($options->{use_template} or defined(my $temp = $options->{template})) {
		unless (defined($temp)) {
			$temp = get_template_object($db, $col, local => $options->{local}, client => $client);
		}
		copy_properties($obj, $temp, nonew => $options->{nonew});
	}
	
	my $collection = get_collection($client, $db, $col);

	my $json = pm2json($obj, $options->{id}, 0, {contributor => $options->{contrib}}, $rem_props);
	my $output = $collection->insert($json);
	return $output;
}


# @category Database Write Access
# Adds an object from a file //file// to the collection //col// in the database //db//. First it matches its properties with the template object for this collection (unless your options say otherwise).
# 
# Note that you need write access to the database for this. You will be asked for credentials if you don't specify them.
# 
# Contained in extension ''polyDB''.
# @param String file polymake object stored in a file
# @param String db database name
# @param String col collection name
# @option String id unique identifier, if you don't specify one, polyDB will try to create one from the object name or file name, if this does not work out one will be created automatically
# @option String contrib set the contributor
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option Bool use_template set to 1 to match properties with a template object. 
# @option Bool nonew set to 1 if you don't want to compute missing properties but only delete surplus ones (only takes effect if use_template is also set to 1)
# @option Core::Object template can be precomputed for better performance when applying to multiple objects
# @option MongoClient client
# @return String
user_function db_insert_from_file($, $, $, {local => 0, username => $db_user, password => $db_pwd, id => "", contrib => "", nonew => 0, use_template => 0, template => undef, client => undef, rem_props => undef}) {
	my ($file, $db, $col, $options) = @_;

	my $obj = User::load($file);
	
	my $id = $options->{id};
	
	unless ($id) {
		if ($id = generate_id($file, $db, $col)) {
			$options->{"id"} = $id;
		}
	}
	
	return db_insert($obj, $db, $col, $options);
}


# @category Database Write Access
# Adds a list of objects from files to the collection //col// in the database //db//. It assumes that the objects names can be used to generate unique ids. Objects with ids that are already contained in the database will be skipped (and moved to //move_dir// if indicated).
# 
# TODO: It still processes (and inserts) the files one by one (which is fine if the objects are relatively large). If one wants to insert a large number of very small objects there is a more efficient way of doing this.
# 
# Note that you need write access to the database for this. You will be asked for credentials if you don't specify them.
# 
# Contained in extension ''polyDB''.
# @param Array<String> files list of file names
# @param String db database name
# @param String col collection name
# @option String contrib
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option Bool use_template set to 1 to match properties with a template object. 
# @option Bool nonew set to 1 if you don't want to compute missing properties but only delete surplus ones (only takes effect if use_template is also set to 1)
# @option String move_dir directory in which processed files are moved
# @option Bool verbose print database output
# @option MongoClient client
user_function db_batch_insert ($, $, $, {contrib => "", local => 0, username => $db_user, password => $db_pwd, nonew => 0, use_template => 0, move_dir => "", client => undef, rem_props => undef}){
	my ($files, $db_name, $collection, $options) = @_;
	
	my @files = @$files;
	
	# get client if not given by the options
	my $client;
	unless (defined($client = $options->{client})) {
		$client = get_client($options);
	}

	# get template object if needed
	if ($options->{use_template}){
		my $temp = get_template_object($db_name, $collection, local => $options->{local}, client => $client);
	}

	my $rem_props;
	unless (defined($rem_props = $options->{rem_props})) {
		$rem_props = ["database","collection"];
		if (my $type = get_type($client, $db, $col)) {
			#push @$rem_props, ("version", "contributor", "type", "app");
			push @$rem_props, keys %$type;
		}
	}


	# get first object
	my $fst = User::load($files[0]);
		
	print "inserting ...\n";
	foreach (@files) {
		my $obj = User::load($_);
		$obj->CONE_DIM;
		if ($options->{use_template}) {
			copy_properties($obj, $temp, nonew => $options->{nonew});
		}
	}

	my $col = get_collection($client, $db_name, $collection);
	
	my $md = $options->{move_dir};
	if ($md) {
		system("mkdir -p $md");
	}
	
	foreach my $file (@files) {
		my $obj = User::load($file);
		my $id = generate_id($obj->name, $db_name, $collection);
		
		if ($col->find_one({'_id'=>$id})) {
			if ($md) {
				system("mv $file $md");
			}	
			next;
		}

		my $json = pm2json($obj, $options->{id}, 0, {contributor => $options->{contrib}}, $rem_props);
		my $output = $col->insert($json);
		if ($options->{verbose}) {print "$output ";}

		if ($md) {
			system("mv $file $md");
		}
	}
	
	unless (defined($options->{client})){
		undef $client;
	}
	print "\n";
}
