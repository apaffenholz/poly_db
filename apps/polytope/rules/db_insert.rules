# Copyright (c) 2013 Silke Horn
# http://solros.de/polymake/poly_database
# 
# This file is part of the polymake extension poly_database.
# 
# poly_database is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# poly_database is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with poly_database.  If not, see <http://www.gnu.org/licenses/>.

use Term::ReadKey;


user_function get_credentials {
	# TODO: cache, key chain??
	print "user name: ";
	my $u= <STDIN>;
	ReadMode 2;
	print "password: ";
	my $p= <STDIN>;
	ReadMode 0;
	print "\n";
	chomp($u);
	chomp($p);
	return ($u,$p);
}

# @category Database Insertion
# Adds an object //obj// to the collection //col// in the database //db//. First it matches its properties with the template object for this collection (unless your options say otherwise).
# 
# Note that you need write access to the database for this. You will be asked for credentials if you don't specify them.
# 
# Contained in extension ''poly_database''.
# @param Core::Object obj
# @param String db database name
# @param String col collection name
# @param String id unique identifier
# @param String contrib
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option Bool nonew set to 1 if you don't want to compute missing properties
# @option Bool force set to 1 if to prevent matching properties with a template object. Only use this if you absolutely know what you're doing!!!
# @option Core::RuleChain schedule can be precomputed for better performance when applying to multiple objects
# @option Core::Object template can be precomputed for better performance when applying to multiple objects
# @return String
user_function poly_db_insert ($, $, $, $, $, {local => 0, username => "", password => "", nonew => 0, force => 0, schedule => undef, template => undef}){
	my ($obj, $db, $col, $id, $contrib, $options) = @_;
 	
 	my $local = $options->{local};
 	my $u = $options->{username};
 	my $p = $options->{password};
	my $nonew = $options->{nonew};
	my $force = $options->{force};
	my $sched = $options->{schedule};
	my $temp = $options->{template};
		
	unless ($u || $local) {
		my @cred = get_credentials;
		$u = $cred[0];
		$p = $cred[1];
	}
#	print $obj->list_properties; print "\n";
	unless ($force) {
		unless ($temp) {
			$temp = get_template_object($db, $col, local=>$local);
#			print $temp->list_properties();
#			print "\n";
		}
		copy_properties_db($obj, $temp, nonew=>$nonew, schedule=>$sched);
#		print $obj->list_properties;
	}
	
	my $client = get_client($local, $u, $p);	
	my $collection = get_collection($client, $db, $col);
	
	my $json = pm2json($obj, $id, $contrib);
	my $output = $collection->insert($json);
	return $output;
}


# @category Database Insertion
# Adds an object from a file //file// to the collection //col// in the database //db//. First it matches its properties with the template object for this collection (unless your options say otherwise).
# 
# Note that you need write access to the database for this. You will be asked for credentials if you don't specify them.
# 
# Contained in extension ''poly_database''.
# @param String file polymake object stored in a file
# @param String db database name
# @param String col collection name
# @param String contrib
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option String id unique identifier
# @option Bool nonew set to 1 if you don't want to compute missing properties
# @option Bool force set to 1 if to prevent matching properties with a template object. Only use this if you absolutely know what you're doing!!!
# @option Core::RuleChain schedule can be precomputed for better performance when applying to multiple objects
# @option Core::Object template can be precomputed for better performance when applying to multiple objects
# @return String
user_function poly_db_insert_from_file($, $, $, $, {local => 0, username => "", password => "", id => "", nonew => 0, force => 0, schedule => undef, template => undef}) {
	my ($file, $db, $col, $contrib, $options) = @_;

	my $obj = User::load($file);
	
	my $id = $options->{id};
	
	unless ($id) {
		unless ($id = generate_id($file, $db, $col)) {
			return;
		}
	}
	
	return poly_db_insert($obj, $db, $col, $id, $contrib, $options);
}


# @category Database Insertion
# Adds a list of objects from files to the collection //col// in the database //db//. First it matches its properties with the template object for this collection (unless your options say otherwise).
# 
# Note that you need write access to the database for this. You will be asked for credentials if you don't specify them.
# 
# Contained in extension ''poly_database''.
# @param Array<String> files list of file names
# @param String db database name
# @param String col collection name
# @param String contrib
# @option Bool local set to 1 if you want to use a local database (on localhost), default 0
# @option String username
# @option String password
# @option Bool nonew set to 1 if you don't want to compute missing properties
# @option Bool force set to 1 if to prevent matching properties with a template object. Only use this if you absolutely know what you're doing!!!
# @option String move_dir directory in which processed files are moved
# @option Bool verbose
user_function poly_db_batch_insert ($, $, $, $, {local => 0, username => "", password => "", nonew => 0, force => 0, move_dir => ""}){
	my ($files, $db_name, $collection, $contrib, $options) = @_;
	my $local = $options->{local};
	my $nonew = $options->{nonew};
	my $u = $options->{username};
	my $p = $options->{password};
	
	my @files = @$files;
	
	my @c;
	unless ($u || $local) {
		@c = get_credentials();
		$u = $c[0];
		$p = $c[1];
	}

	my $fst = User::load($files[0]);
	
	my $temp = get_template_object($db_name, $collection, local=>$local);
#	print $temp; print "\n";
	my $sched = undef;
	unless ($nonew) {
		$sched = $fst->get_schedule($temp->list_properties);
	}
	print "inserting ...\n";
	foreach (@files) {
		my $obj = User::load($_);
		$obj->CONE_DIM;
#		print $obj->name; print "\n";
		copy_properties_db($obj, $temp, schedule=>$sched, nonew=>$nonew);
#		print "copy_properties_db done\n";
	}

	my $client = get_client($local, $u, $p);	
	my $col = get_collection($client, $db_name, $collection);
	
	my $md = $options->{move_dir};
	if ($md) {
		system("mkdir -p $md");
	}
	
	foreach my $file (@files) {
		my $obj = User::load($file);
		my $id = generate_id($obj->name, $db_name, $collection);
		
		if ($col->find_one({'_id'=>$id})) {
			if ($md) {
				system("mv $file $md");
			}	
			next;
		}

		my $json = pm2json($obj, $id, $contrib);
		my $output = $col->insert($json);
		if ($options->{verbose}) {print "$output ";}

		if ($md) {
			system("mv $file $md");
		}
	}
	print "\n";
}
