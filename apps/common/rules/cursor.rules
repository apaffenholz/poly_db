# Copyright (c) 2013-2014 Silke Horn
# http://solros.de/polymake/poly_db
# 
# This file is part of the polymake extension poly_db.
# 
# poly_db is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# poly_db is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with poly_db.  If not, see <http://www.gnu.org/licenses/>.

CREDIT poly_db

use MongoDB;
use MongoDB::OID;


object DatabaseCursor {

	# The hostname of the database, default 'polymake.org'. (Functionality not implemented yet.)
	property HOST : String;
	
	# The port of the database, default 27017.  (Functionality not implemented yet.)
	property PORT : Int;
	
	# The name of the authentication database, default 'admin'.  (Functionality not implemented yet.)
	property AUTH_DB : String;

	# The name of the type database, default 'pm'.  (Functionality not implemented yet.)
	property TYPE_DB : String;

	# Your user name, default 'polymake'.
	property USER_NAME : String;

	# Your password, default 'database'.
	property PASSWORD : String;

	# The name of the database the cursor accesses. Needed for initialization.
	property DATABASE : String;
	
	# The name of the collection the cursor accesses. Needed for initialization.
	property COLLECTION : String;


	# The query. See [[http://polymake.org/doku.php/tutorial/poly_db_tutorial|the tutorial]] for information.
	property QUERY : HASH;


	# The type of the objects in the [[COLLECTION]]. Will be created automatically.
	property TYPE : String;
	
	# The application of the objects in the [[COLLECTION]]. Will be created automatically.
	property APP : String;

	# The number of objects matching [[QUERY]].
	property COUNT : Int;

	# Set this to 1 if you want to access a local database server. (Functionality not implemented yet.)
	property LOCAL : Bool;


	# The actual MongoCursor. The "heart" of this object. Will be created automatically.
	property CURSOR : SCALAR;


	# Specify how you want to sort the objects.
	property SORT_BY : String;

	# Specify where to start.
	property START_POSITION : Int;

	
	rule initial : DATABASE : {
		unless(defined($this->DATABASE = $db_name)) {
			croak("\nillegal input: to define a DatabaseCursor you have to specify a DATABASE and COLLECTION");
		}
	}

	rule initial : COLLECTION : {
		unless(defined($this->COLLECTION = $collection_name)) {
			croak("\nillegal input: to define a DatabaseCursor you have to specify a DATABASE and COLLECTION");
		}
	}

	rule initial : QUERY : {
		$this->QUERY = {};
	}
	
	rule initial : LOCAL : {
		$this->LOCAL = 0;
	}

	rule initial : USER_NAME : {
		$this->USER_NAME = $db_user;
	}
	
	rule initial : PASSWORD : {
		$this->PASSWORD = $db_pwd;
	}


	rule initial : TYPE, APP : {
		my $client = get_client($this->LOCAL, $this->USER_NAME, $this->PASSWORD);
		my $type = get_type($client, $this->DATABASE, $this->COLLECTION);
		my $app = $type->{'app'};
		my $type = $type->{'type'};
		$this->APP = $app;
		$this->TYPE = $type;
	}
	precondition : exists (DATABASE);
	precondition : exists (COLLECTION);
	
	rule CURSOR : DATABASE, COLLECTION, QUERY, LOCAL{
		my $client = get_client($this->LOCAL, $this->USER_NAME, $this->PASSWORD);
		my $col = $client->get_database($this->DATABASE)->get_collection($this->COLLECTION);
		my $cursor = $col->find($this->QUERY);
#		print %{$cursor->explain};
		$cursor->has_next; # this seems to be necessary to circumvent restricted hash problems...
		$this->CURSOR = $cursor;
	}

	rule COUNT : CURSOR {
		$this->COUNT = $this->CURSOR->count;
	}


	# Returns the next object.
	# @return Core::Object
	user_method next {
		my $this = shift;
		my $type = User::application($this->APP)->eval_type($this->TYPE);
		my $p = $this->CURSOR->next;
		unless ($p) {print "no such object"; return;}
		return $type->construct->(%$p);
	}

	# Returns true if there is another object to fetch.
	# @return Bool
	user_method has_next {
		my $this = shift;
		return $this->CURSOR->has_next;
	}
	
	# Reset the [[CURSOR]].
#	user_method reset {
#		my $this = shift;
##		$this->CURSOR->reset->has_next;
#		my $client = get_client($this->LOCAL);
#		my $col = $client->get_database($this->DATABASE)->get_collection($this->COLLECTION);
#		my $cursor = $col->find($this->QUERY);
#		$cursor->has_next; # this seems to be necessary to circumvent restricted hash problems...
#		$this->CURSOR = $cursor;
#	}
	
}
